using System;
using System.Collections.Generic;
using Items;
using Logs;
using UnityEngine;

namespace Antagonists
{
	[System.Serializable]
	public class ObjectiveAttribute
	{
		public string name;
		[HideInInspector]
		public short index = -1;

		public ObjectiveAttributeType type;
		public string PlayerID { get; set; }
		public int Number { get; set; }
		public string ItemID { get; set; }
		public short ItemTraitIndex { get; set; }
	}

	public enum ObjectiveAttributeType
	{
		ObjectiveAttributePlayer,
		ObjectiveAttributeNumber,
		ObjectiveAttributeItem,
		ObjectiveAttributeItemTrait
	}

	/// <summary>
	/// The base class ScriptableObject for all antagonist objectives
	/// </summary>
	public abstract class Objective : ScriptableObject
	{

		/// <summary>
		/// Used for adding custom attributes to admin panel
		/// </summary>
		public List<ObjectiveAttribute> attributes = new List<ObjectiveAttribute>();

		/// <summary>
		/// The player who has this objective
		/// </summary>
		public Mind Owner { get; protected set; }

		/// <summary>
		/// Is that objective may be done only after round?
		/// </summary>
		[SerializeField]
		protected bool isEndRoundObjective = false;
		/// <summary>
		/// Is that objective may be done only after round?
		/// </summary>
		public bool IsEndRoundObjective => isEndRoundObjective;

		public string ID { get; protected set; }

		/// <summary>
		/// The name of the objective type
		/// </summary>
		[SerializeField]
		protected string objectiveName;
		/// <summary>
		/// The name of the objective type
		/// </summary>
		public string ObjectiveName => objectiveName;

		/// <summary>
		/// Can antags get this objective more than once?
		/// </summary>
		public bool IsUnique;

		/// <summary>
		/// The description of the objective which is shown to players. Usually generated by the objective when it is setup.
		/// </summary>
		[SerializeField]
		protected string description;
		/// <summary>
		/// The description of the objective which is shown to players. Usually generated by the objective when it is setup.
		/// </summary>
		public string Description => description;

		/// <summary>
		/// Variable to override the IsComplete function. Useful for free/custom objectives.
		/// </summary>
		protected bool Complete;

		/// <summary>
		/// Whether the Ai job can have this objective
		/// </summary>
		public bool aiCanHave;

		public short GetAttributeIndex(ObjectiveAttribute attribute)
		{
			return (short)attributes.IndexOf(attribute);
		}

		/// <summary>
		/// Check if this objective is possible for a player, defaults to true if not overriden
		/// </summary>
		public bool IsPossible(Mind candidate)
		{
			if (aiCanHave == false && candidate.occupation != null && candidate.occupation.JobType == JobType.AI)
			{
				return false;
			}

			return IsPossibleInternal(candidate);
		}

		protected virtual bool IsPossibleInternal(Mind candidate)
		{
			return true;
		}

		public virtual string GetDescription()
		{
			return description;
		}

		/// <summary>
		/// Sets the owner of the objective and performs setup if required
		/// </summary>
		public void DoSetup(Mind owner)
		{
			Owner = owner;
			ID = Guid.NewGuid().ToString();

			try
			{
				Setup();
			}
			catch (Exception e)
			{
				Loggy.LogError($"Failed to set up objectives for {this.name}" +e.ToString());
			}

		}

		/// <summary>
		/// Sets the owner of the objective and performs setup if required
		/// </summary>
		public void DoSetupInGame(Mind owner)
		{
			Owner = owner;
			ID = Guid.NewGuid().ToString();

			try
			{
				if (attributes.Count == 0)
					Setup();
				else
					SetupInGame(); // need to handle attributes
			}
			catch (Exception e)
			{
				Loggy.LogError($"Failed to set up objectives for {this.name}" +e.ToString());
			}
		}

		/// <summary>
		/// Perform initial setup of the objective if needed
		/// </summary>
		protected abstract void Setup();

		/// <summary>
		/// Perform setup of the objective if needed
		/// </summary>
		protected virtual void SetupInGame()
		{

		}

		/// <summary>
		/// Shows if this objective is complete or not
		/// </summary>
		public bool IsComplete()
		{
			return (Complete || CheckCompletion());
		}

		public virtual string GetShortDescription()
		{
			return description;
		}

		/// <summary>
		/// Manually set objective as complete
		/// </summary>
		public void SetAsComplete()
		{
			Complete = true;
		}

		/// <summary>
		/// Defines how to check the completion of the objective.
		/// </summary>
		protected abstract bool CheckCompletion();

		/// <summary>
		/// Checks through all the storage recursively
		/// </summary>
		protected bool CheckStorageFor(string name, int count)
		{
			if (Owner.Body.DynamicItemStorage == null)
			{
				Loggy.LogError($"Unable to find dynamic storage for {Owner.Body} / {Owner.Body.PlayerInfo.Username}");
				//If they have no storage then fail, as they can't have the item
				return false;
			}

			return CheckStorage(Owner.Body.DynamicItemStorage, default, name) >= count;
		}

		/// <inheritdoc cref="CheckStorageFor(string, int)"/>
		protected bool CheckStorageFor(Type component, int count)
		{
			return CheckStorage(Owner.Body.DynamicItemStorage, component, default) >= count;
		}

		private int CheckStorage(DynamicItemStorage itemStorage, Type component, string name)
		{
			int count = 0;
			foreach (var slot in itemStorage.GetItemSlotTree())
			{
				count += CheckSlot(slot, component, name);
			}
			return count;
		}

		private int CheckStorage(ItemStorage itemStorage, Type component, string name)
		{
			int count = 0;
			foreach (var slot in itemStorage.GetItemSlotTree())
			{
				count += CheckSlot(slot, component, name);
			}
			return count;
		}

		private int CheckSlot(ItemSlot slot, Type component, string name)
		{
			if (slot.IsEmpty) return 0;

			//Check if current Item is the one we need
			if ((component != null && slot.ItemObject.TryGetComponent(component, out _)) ||
					slot.ItemObject.GetComponent<ItemAttributesV2>()?.InitialName == name)
			{
				//If stackable count stack
				if (slot.ItemObject.TryGetComponent<Stackable>(out var stackable))
				{
					return stackable.Amount;
				}

				return 1;
			}

			//Check to see if this item has storage, and do checks on that
			if (slot.ItemObject.TryGetComponent<DynamicItemStorage>(out var itemStorage))
			{
				return CheckStorage(itemStorage, component, name);
			}

			if (slot.ItemObject.TryGetComponent<ItemStorage>(out var storage))
			{
				return CheckStorage(storage, component, name);
			}

			return 0;
		}
	}
}
