using System;
using UnityEngine;

/// <summary>
/// Lighting System manager. 
/// Orchestrates Mask Renderers and Post Processor to apply lighting to the game scene.
/// </summary>
[RequireComponent(typeof(Camera))]
public class LightingSystem : MonoBehaviour
{
	/// <summary>
	/// FoV Projector position offset in local space.
	/// Assumption that it may be changed during game. Otherwise it should be moved in to rendering settings.
	/// </summary>
	public Vector3 fovCenterOffset;
	public float fovDistance;
	public RenderSettings renderSettings;
	public MaterialContainer materialContainer;

	private static Func<Vector3, Vector3, Vector2, Vector2> HandlePPPositionRequest;

	private Camera mMainCamera;
	private OcclusionMaskRenderer mOcclusionRenderer;
	private LightMaskRenderer mLightMaskRenderer;
	private BackgroundRenderer mBackgroundRenderer;
	private PostProcessingStack mPostProcessingStack;
	private PixelPerfectRT mGlobalOcclusionMask;
	private PixelPerfectRT mFloorOcclusionMask;
	private PixelPerfectRT mOcclusionMaskExtended;
	private PixelPerfectRT mObstacleLightMask;
	private PixelPerfectRT mOcclusionPPRT;
	private PixelPerfectRT mlightPPRT;
	private bool mDoubleFrameRendererSwitch;	
	private bool mMatrixRotationMode;
	private float mMatrixRotationModeBlend;

	public bool matrixRotationMode
	{
		get
		{
			return mMatrixRotationMode;
		}

		set
		{
			if (mMatrixRotationMode == value)
				return;

			mMatrixRotationMode = value;
		}
	}

	/// <summary>
	/// Holds the global occlusion mask aka "Fit Occlusion Mask", which is generated by transforming occlusionMaskExtended using PPRT Transform.shader. Used in shaders which are affected by occlusion.
	/// </summary>
	private PixelPerfectRT globalOcclusionMask
	{
		get
		{
			return mGlobalOcclusionMask;
		}

		set
		{
			if (mGlobalOcclusionMask == value)
				return;

			if (mGlobalOcclusionMask != null)
			{
				mGlobalOcclusionMask.Release();
			}

			mGlobalOcclusionMask = value;

			Shader.SetGlobalTexture("_FovMask", value.renderTexture);
		}
	}

	/// <summary>
	/// Holds the occlusion mask which only masks out the floor based on the position of walls / the player
	/// </summary>
	private PixelPerfectRT floorOcclusionMask
	{
		get
		{
			return mFloorOcclusionMask;
		}

		set
		{
			if (mFloorOcclusionMask == value)
				return;

			if (mFloorOcclusionMask != null)
			{
				mFloorOcclusionMask.Release();
			}

			mFloorOcclusionMask = value;
		}
	}

	/// <summary>
	/// Holds the final occlusion mask which occludes walls and floors and
	/// from which the Fit Occlusion Mask (globalOcclusionMask) will be generated.
	/// </summary>
	private PixelPerfectRT occlusionMaskExtended
	{
		get
		{
			return mOcclusionMaskExtended;
		}

		set
		{
			if (mOcclusionMaskExtended == value)
				return;

			if (mOcclusionMaskExtended != null)
			{
				mOcclusionMaskExtended.Release();
			}

			mOcclusionMaskExtended = value;
		}
	}

	private PixelPerfectRT obstacleLightMask
	{
		get
		{
			return mObstacleLightMask;
		}

		set
		{
			if (mObstacleLightMask == value)
				return;

			if (mObstacleLightMask != null)
			{
				mObstacleLightMask.Release();
			}

			mObstacleLightMask = value;
		}
	}

	private OperationParameters operationParameters { get; set; }

	public static Vector2 GetPixelPerfectPosition(Vector3 iPosition, Vector3 iPreviousPosition, Vector2 iPreviousFilteredPosition)
	{
		if (HandlePPPositionRequest == null)
		{
			return iPosition;
		}

		return HandlePPPositionRequest(iPosition, iPreviousPosition, iPreviousFilteredPosition);
	}

	private static void ValidateMainCamera(Camera iMainCamera, RenderSettings iRenderSettings)
	{
		if (iMainCamera.backgroundColor.a > 0)
		{
			UnityEngine.Debug.Log("FovSystem Camera Validation: Camera backgroundColor.a must be 0. This is required to create background mask. Adjusted...");

			iMainCamera.backgroundColor = new Color(iMainCamera.backgroundColor.r, iMainCamera.backgroundColor.g, iMainCamera.backgroundColor.b, 0);
		}

		if (((LayerMask)iMainCamera.cullingMask).HasAny(iRenderSettings.lightSourceLayers))
		{
			UnityEngine.Debug.Log("FovSystem Camera Validation: Camera does not cull one of Light Source Layers! Light System may not work currently.");
		}

		if (((LayerMask)iMainCamera.cullingMask).HasAny(iRenderSettings.backgroundLayers))
		{
			UnityEngine.Debug.Log("FovSystem Camera Validation: Camera does not cull one of Background Layers! Light System wound be able to mask background and would not work correctly.");
		}
	}

	private void OnEnable()
	{
		HandlePPPositionRequest += ProviderPPPosition;

		// Initialize members.
		mMainCamera = gameObject.GetComponent<Camera>();

		if (mMainCamera == null)
			throw new Exception("FovSystemManager require Camera component to operate.");

		ValidateMainCamera(mMainCamera, renderSettings);

		if (mOcclusionRenderer == null)
		{
			mOcclusionRenderer = OcclusionMaskRenderer.InitializeMaskRenderer(gameObject, renderSettings.occlusionLayers, materialContainer.OcclusionMaskShader);
		}

		if (mLightMaskRenderer == null)
		{
			mLightMaskRenderer = LightMaskRenderer.InitializeMaskRenderer(gameObject);
		}

		if (mBackgroundRenderer == null)
		{
			mBackgroundRenderer = BackgroundRenderer.InitializeMaskRenderer(gameObject);
		}

		if (mPostProcessingStack == null)
		{
			mPostProcessingStack = new PostProcessingStack(materialContainer);
		}
	}

	private Vector2 ProviderPPPosition(Vector3 iPosition, Vector3 iPreviousPosition, Vector2 iPreviousFilteredPosition)
	{
		return operationParameters.occlusionPPRTParameter.GetFilteredRendererPosition(iPosition, iPreviousPosition, iPreviousFilteredPosition);
	}

	private void OnDisable()
	{
		// Set global occlusion white, so occlusion dependent shaders will show appropriately while system is off.
		Shader.SetGlobalTexture("_FovMask", Texture2D.whiteTexture);

		// Default parameters to force parameters update on enable.
		operationParameters = default(OperationParameters);

		HandlePPPositionRequest -= ProviderPPPosition;
	}

	private void Update()
	{
		// Monitor state to detect when we should trigger reinitialization of rendering textures.
		var _newParameters = new OperationParameters(mMainCamera, renderSettings, matrixRotationMode);

		bool _shouldReinitializeTextures = _newParameters != operationParameters;

		if (_shouldReinitializeTextures)
		{
			operationParameters = _newParameters;

			ResolveRenderingTextures(operationParameters);
		}

		// Blend switch for matrix rotation effects.
		// Used to smooth effects in and out.
		if (mMatrixRotationMode == true)
		{
			mMatrixRotationModeBlend = Mathf.MoveTowards(mMatrixRotationModeBlend, 1, Time.unscaledDeltaTime * 5);
		}
		else
		{
			mMatrixRotationModeBlend = 0;
		}
	}	

	private void ResolveRenderingTextures(OperationParameters iParameters)
	{
		// Prepare render textures.
		floorOcclusionMask = new PixelPerfectRT(operationParameters.fovPPRTParameter);
		occlusionMaskExtended = new PixelPerfectRT(operationParameters.fovPPRTParameter);

		globalOcclusionMask = new PixelPerfectRT(operationParameters.lightPPRTParameter);

		obstacleLightMask = new PixelPerfectRT(operationParameters.obstacleLightPPRTParameter);

		// Let members handle their own textures.
		// Possibly move to container?
		mPostProcessingStack.ResetRenderingTextures(iParameters);
		mBackgroundRenderer.ResetRenderingTextures(iParameters);
	}

	private void OnPreRender()
	{
		if (renderSettings.doubleFrameRenderingMode && mDoubleFrameRendererSwitch == false)
		{
			Shader.SetGlobalVector("_FovMaskTransformation", globalOcclusionMask.GetTransformation(mMainCamera));
			return;
		}

		using (new DisposableProfiler("1. Occlusion Mask Render (No Gfx Time)"))
		{
			mOcclusionPPRT = mOcclusionRenderer.Render(mMainCamera, operationParameters.occlusionPPRTParameter, matrixRotationMode);

			if (mMatrixRotationModeBlend > 0.001f)
			{
				mPostProcessingStack.BlurOcclusionMaskRotation(mOcclusionPPRT.renderTexture, renderSettings, operationParameters.cameraOrthographicSize, mMatrixRotationModeBlend);
			}
			
		}

		using (new DisposableProfiler("2. Generate FoV"))
		{
			if (occlusionMaskExtended == null)
			{
				floorOcclusionMask = new PixelPerfectRT(operationParameters.fovPPRTParameter);
				occlusionMaskExtended = new PixelPerfectRT(operationParameters.fovPPRTParameter);
			}
			else
			{
				floorOcclusionMask.Update(operationParameters.fovPPRTParameter);
				occlusionMaskExtended.Update(operationParameters.fovPPRTParameter);
			}

			// This step will result in two masks: Generated "Extended Occlusion Mask" / occlusionMaskExtended is an intermediate mask used for calculating occlusion on floors,
			// occlusionMaskExtendedWithWall adds in wall occlusion and will be stored for later use in Light Mixing
			Vector3 _fovCenterInWorldSpace = transform.TransformPoint(fovCenterOffset);
			Vector3 _fovCenterOffsetInViewSpace = mMainCamera.WorldToViewportPoint(_fovCenterInWorldSpace) - new Vector3(0.5f, 0.5f, 0);
			Vector3 _fovCenterOffsetInExtendedViewSpace = _fovCenterOffsetInViewSpace * (float)operationParameters.cameraOrthographicSize / mOcclusionPPRT.orthographicSize;
			
			mPostProcessingStack.GenerateFovMask(mOcclusionPPRT, floorOcclusionMask, occlusionMaskExtended, renderSettings, _fovCenterOffsetInExtendedViewSpace, fovDistance, operationParameters);
		}

		using (new DisposableProfiler("3. Fit Occlusion Mask"))
		{
			// These step calculate the "Fit Occlusion Mask" / globalOcclusionMask which will be used during scene rendering.
			globalOcclusionMask.Update(operationParameters.lightPPRTParameter);
			// Note: Fit Occlusion Mask is cut from "Extended Occlusion Mask" to be used in Occlusion affected shaders during scene render.
			PixelPerfectRT.Transform(occlusionMaskExtended, globalOcclusionMask, materialContainer.PPRTTransformMaterial);

			// Update shader global transformation for occlusionMaskExtended so sprites can transform mask correctly.
			Shader.SetGlobalVector("_FovMaskTransformation", globalOcclusionMask.GetTransformation(mMainCamera));
		}

		using (new DisposableProfiler("4. Blur Fit Occlusion Mask"))
		{
			// Note: This blur is used only with shaders during scene render, so 1 pass should be enough.
			mPostProcessingStack.BlurOcclusionMask(globalOcclusionMask.renderTexture, renderSettings, operationParameters.cameraOrthographicSize);

			globalOcclusionMask.renderTexture.filterMode = FilterMode.Point;
		}

		// Note: After execution of this method, MainCamera.Render will be executed and scene will be drawn.
	}

	private void OnRenderImage(RenderTexture iSource, RenderTexture iDestination)
	{
		if (renderSettings.doubleFrameRenderingMode)
		{
			if (mDoubleFrameRendererSwitch)
			{
				var _blitMaterial = materialContainer.blitMaterial;
				_blitMaterial.SetVector("_LightTransform", mlightPPRT.GetTransformation(mMainCamera));
				_blitMaterial.SetVector("_OcclusionTransform", occlusionMaskExtended.GetTransformation(mMainCamera));

				Graphics.Blit(iSource, iDestination, _blitMaterial);

				mDoubleFrameRendererSwitch = false;
				return;
			}

			mDoubleFrameRendererSwitch = true;
		}

		if (materialContainer.blitMaterial == null)
		{
			Debug.Log($"FovSystemManager: Unable to blit Fov mask. {nameof(materialContainer.blitMaterial)} not provided.");
			return;
		}

		if (globalOcclusionMask == null)
		{
			Graphics.Blit(iSource, iDestination);
			return;
		}

		using (new DisposableProfiler("5. Light Mask Render (No Gfx Time)"))
		{
			mlightPPRT = mLightMaskRenderer.Render(
				mMainCamera,
				operationParameters.lightPPRTParameter,
				occlusionMaskExtended,
				renderSettings,
				matrixRotationMode);
		}

		using (new DisposableProfiler("6. Generate Obstacle Light Mask"))
		{
			mPostProcessingStack.CreateWallLightMask(
				mlightPPRT,
				obstacleLightMask,
				renderSettings,
				operationParameters.cameraOrthographicSize);
		}
		
		// Debug View Selection.
		if (renderSettings.viewMode == RenderSettings.ViewMode.LightLayer)
		{
			PixelPerfectRT.Transform(mlightPPRT, iDestination, mMainCamera, materialContainer.PPRTTransformMaterial);

			return;
		}
		else if (renderSettings.viewMode == RenderSettings.ViewMode.WallLayer)
		{
			PixelPerfectRT.Transform(obstacleLightMask, iDestination, mMainCamera, materialContainer.PPRTTransformMaterial);

			return;
		}
		else if (renderSettings.viewMode == RenderSettings.ViewMode.FovObstacle)
		{
			PixelPerfectRT.Transform(globalOcclusionMask, iDestination, mMainCamera, materialContainer.PPRTTransformMaterial);

			return;
		}
		else if (renderSettings.viewMode == RenderSettings.ViewMode.FovObstacleExtendedFloorOnly)
		{
			PixelPerfectRT.Transform(floorOcclusionMask, iDestination, mMainCamera, materialContainer.PPRTTransformMaterial);

			return;
		}
		else if (renderSettings.viewMode == RenderSettings.ViewMode.FovObstacleExtended)
		{
			PixelPerfectRT.Transform(occlusionMaskExtended, iDestination, mMainCamera, materialContainer.PPRTTransformMaterial);

			return;
		}
		else if (renderSettings.viewMode == RenderSettings.ViewMode.Obstacle)
		{
			PixelPerfectRT.Transform(mOcclusionPPRT, iDestination, mMainCamera, materialContainer.PPRTTransformMaterial);

			return;
		}

		using (new DisposableProfiler("7. Light Mask Blur"))
		{
			mPostProcessingStack.BlurLightMask(mlightPPRT.renderTexture, renderSettings, operationParameters.cameraOrthographicSize, mMatrixRotationModeBlend);
		}

		RenderTexture _backgroundMask = null;

		using (new DisposableProfiler("8. Render Background"))
		{
			_backgroundMask = mBackgroundRenderer.Render(renderSettings);
		}

		// Debug Views Selection.
		if (renderSettings.viewMode == RenderSettings.ViewMode.LightLayerBlurred)
		{
			PixelPerfectRT.Transform(mlightPPRT, iDestination, mMainCamera, materialContainer.PPRTTransformMaterial);

			return;
		}
		else if (renderSettings.viewMode == RenderSettings.ViewMode.Background)
		{
			Graphics.Blit(_backgroundMask, iDestination);

			return;
		}

		using (new DisposableProfiler("9. Blit Scene with Mixed Lights"))
		{
			mlightPPRT.renderTexture.filterMode = FilterMode.Bilinear;
			obstacleLightMask.renderTexture.filterMode = FilterMode.Bilinear;
			occlusionMaskExtended.renderTexture.filterMode = matrixRotationMode ? FilterMode.Bilinear : FilterMode.Point;

			var _blitMaterial = materialContainer.blitMaterial;
			_blitMaterial.SetTexture("_LightMask", mlightPPRT.renderTexture);
			_blitMaterial.SetTexture("_OcclusionMask", occlusionMaskExtended.renderTexture);
			_blitMaterial.SetTexture("_ObstacleLightMask", obstacleLightMask.renderTexture);
			_blitMaterial.SetVector("_LightTransform", mlightPPRT.GetTransformation(mMainCamera));
			_blitMaterial.SetVector("_OcclusionTransform", occlusionMaskExtended.GetTransformation(mMainCamera));

			_blitMaterial.SetTexture("_BackgroundTex", _backgroundMask);
			_blitMaterial.SetVector("_AmbLightBloomSA", new Vector4(renderSettings.ambient, renderSettings.lightMultiplier, renderSettings.bloomSensitivity, renderSettings.bloomAdd));
			_blitMaterial.SetFloat("_BackgroundMultiplier", renderSettings.backgroundMultiplier);

			Graphics.Blit(iSource, iDestination, _blitMaterial);
		}
	}
}